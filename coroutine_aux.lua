coroutine = require "coroutine"

-- this function thoes the same as a function generated by the coroutine.wrap function.
-- However this function does a status check that isn't natively done by the wrap function.
function run_coroutine(co_table, co_name, arg1, arg2)
    if coroutine.status(co_table[co_name]) ~= "dead" then
        local _, value = coroutine.resume(co_table[co_name], arg1, arg2)
        return value
    end 
end

function get_scheduler()
    local computation_tasks = {}
    local print_tasks = {}
    local frame_dt = 0

    local scheduler = {
        addComputationTask = function (f)
            local co_f = coroutine.create(f)
            table.insert(computation_tasks, co_f)
        end,
        addPrintTask = function (f)
            local co_f = coroutine.create(f)
            table.insert(print_tasks, co_f)
        end,
        executeComputation = function ()
            for idx, task in ipairs(computation_tasks) do
                local status = coroutine.resume(task, frame_dt)
                if status == "dead" then
                    table.remove(computation_tasks, idx)
                end
            end
        end,
        executePrint = function ()
            for idx, task in ipairs(print_tasks) do
                local status = coroutine.resume(task, frame_dt)
                if status == "dead" then
                    table.remove(print_tasks, idx)
                end
            end
        end,
        setDt = function (dt)
            frame_dt = dt
        end
    }
    return scheduler
end